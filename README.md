# genData
A normalization pattern to build, query, and manipulate everything.

(6/28/11)
version 0.5
by Bemi Faison


## DESCRIPTION


genData is a recursive, depth-first iterator and generic parser, for querying objects. genData makes it easy to control iteration and parsing, along with the resulting dataset.


## FILES


* gendata-min.js - genData source file (minified with [UglifyJS](http://marijnhaverbeke.nl/uglifyjs) )
* src/ - Directory containing the source code
* LICENSE - The legal terms and conditions under which this software may be used
* README.md - This readme file


## USAGE


Include `gendata-min.js` in your application.


**Caution** genData _will_ scan objects recursively!! You must define a _parser_ to avoid infinite loops, as there is no built-in error handling.


### Basics


1) Convert stuff to a dataset.


```js

var dataStuff = genData(stuff);

```

A _dataset_ is an array of normalized (i.e., identical) data objects. Below is the datset returned from parsing `{foo: 'bar'}`.


```js

var dataset = genData({foo: 'bar'});
/*
dataset =>
    [
      { // data object #1
       name: '',
       value: {foo: 'bar'}
      },
      { // data object #2 (child of data object #1)
        name: 'foo',
        value: 'bar'
      }
    ]
*/

```

2) Use standard array functions like `.filter()` and `.map()`, to query and manipulate the returned dataset.

```js

var functionsInDataset = dataStuff
  .filter(function (data) {
    return data.value === 'function'
  })
  .map(function (data) {
    return data.value;
  });

```

3) Or, provide _parser_ functions to filter and map stuff for you.

```js

var functionsInStuff = genData(
  stuff,
  function (name, value, parent, dataset, flags) {
    flags.exclude = true;
    if (typeof value === 'function') dataset.push(value);
  }
);


```

### Customizing genData


Modify the structure of data generated from stuff.


```js

var metaStuff = genData(
  stuff,
  function (name, value, parent, dataset, flags) {
    var data = this;
    data.uniqueId = (Math.random() * 1000).toString(20);
    data.shortName = name.substr(0,4);
  }
);

```


Exclude parts of stuff from the dataset.


```js

var stringlessStuff = genData(
  stuff,
  function (name, value, parent, dataset, flags) {
    // tell genData to exclude strings
    flags.exclude = value === 'string';
  }
);

```


Receive a dataset full of objects you recognize and can manipulate.


```js

var myObjs = genData(
  stuff,
  function (name, value, parent, dataset, flags) {
	// access members of the prototype chain when modifying and filtering each data object
  },
  myConstructorAndPrototype
);

```


Piece stuff together by passing multiple _parsers_, in an `Array` object.


```js

var multiParsedStuff = genData(
  stuff,
  [
    filterKeysWithUnderscores,
    denyKeysWithDollarSymbols,
    addUniqueIdProperty,
    addShortNameProperty
  ]
);

```


### Extending genData


Spawn _generators_ to curry genData calls.


```js

var genFiltered = new genData(
  function (name, value, parent, dataset, flags) {
    // if this data's name begins with an underscore...
    if (name.charAt(0) === '_') {
      // exclude from the dataset
      flags.exclude = true;
      // skip scanng object-properties in this data's value
      flags.scanValue = 0;
    }
  },
  function (name, value, parent, dataset, flags) {
    // if this data's name contains a dollar symbol...
    if (name.indexOf('$') > -1) {
      // exclude from the dataset
      flags.exclude = true;
      // skip scanng object-properties in this data's value
      flags.scanValue = 0;
      // stop parsing this data object altogether (skips waiting parser functions - if any)
      flags.parse = 0;
    }
  }
);

```


Extend spawned generators, to compound curried calls for complex data models (e.g., prototypes and structures).


```js

// cache the type of each data's value
var genTypeCaches = new genFiltered(
  function (name, value, parent, dataset, flags) {
    // cache the type of this data's value
    this.cachedType = typeof value; 
  }
);
// init attributes property, and add name/value pair for children prefixed with an underscore
var genAttrData = new genFiltered(
  function (name, value, parent, dataset, flags) {
    this.attributes = {}; // add attributes property to data
    // if this data object has a parent and it's name begins with an underscore...
    if (parent && name.charAt(0) === '_') {
      // tell genData to exclude this data object from the dataset
      flags.exclude = 1;
      // add an attribute to the parent, using this data's name and value
      parent.attributes[name.substr(1)] = value;
    }
  }
);

```


Prototype members to generators (including genData), and the data objects they create can access them via the prototype chain.


```js

// add property to all data objects
genData.prototype.someMember = 'now available to all data objects';
// add method to data objects generated by this generator and any generators spawned from it
genAttrData.prototype.hasAttribute = function (key) {
  return this.attributes.hasOwnProperty(key);
};

```


---

Full documentation is under development.

## LICENSE

Flow is available under the terms of the [MIT-License](http://en.wikipedia.org/wiki/MIT_License#License_terms).

Copyright 2011, Bemi Faison