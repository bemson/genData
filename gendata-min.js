/* genData v2.1.0 | github.com/bemson | (c) 2012, MIT */
!function(inCJS,inAMD,Array,scope){function initGenData(){function genData(stuff){if(this instanceof genData){return this}var parserIdx,data,propertyName,queue=[["",stuff]],nextObj,queueBuffer,item,sharedVars={},parserFlags,parserArgs,parsers=[].slice.call(arguments).slice(1).filter(function(fnc){return typeof fnc==="function"}),totalParsers=parsers.length,dataset=[];function Data(name,value){this.name=name;this.value=value}Data.prototype=(typeof this==="function"?this:genData).prototype;while(queue.length){item=queue.shift();data=new Data(item[0],item[1]);parserIdx=0;parserFlags={omit:0,scan:1,exit:0,parent:null};parserArgs=[item[0],item[1],item[2],dataset,parserFlags,sharedVars];while(parserIdx<totalParsers&&!parserFlags.exit){parsers[parserIdx++].apply(data,parserArgs)}if(parserFlags.omit){data._OMIT=true}else{dataset.push(data)}if(parserFlags.exit){queue=[]}else{queueBuffer=[];nextObj=parserFlags.parent!==null?parserFlags.parent:data.value;if(parserFlags.scan&&typeof nextObj==="object"){for(propertyName in nextObj){if(nextObj.hasOwnProperty(propertyName)){queueBuffer.push([propertyName,nextObj[propertyName],data])}}queue=queueBuffer.concat(queue)}}}return dataset}genData.spawn=function spawn(){var parentGenerator=this,parsers=[].slice.call(arguments).filter(function(arg){return typeof arg==="function"});function generator(stuff){if(this instanceof generator){return this}return parentGenerator.apply(typeof this==="function"?this:generator,[stuff].concat(parsers,[].slice.call(arguments).slice(1)))}generator.prototype=new parentGenerator;generator.spawn=spawn;return generator};genData.version="2.1.0";return genData}if(inCJS){module.exports=initGenData()}else if(inAMD){define('genData', initGenData)}else if(!scope.genData){scope.genData=initGenData()}}(typeof exports!="undefined",typeof define=="function",Array,this);